import os
import sys
import csv
import argparse
from multiprocessing import Pool, Lock
from androguard.misc import AnalyzeAPK

lock = Lock()

__location__ = os.path.realpath(
    os.path.join(os.getcwd(), os.path.dirname(__file__)))

##
##fucntion gets list of all apks from a given directory
##
def get_apk_files(directory):
    apks = list()

    for root, dirs, files in os.walk(directory):
        for filename in files:
            if '.apk' in filename:
                apks.append(os.path.join(root, filename))

    return apks

##
##fucntion gets permissions from apk and checks it against app_permissions.txt
##
def get_apk_permissions_dict(app):
    permission_present = dict()
    try:
        with open(os.path.join(__location__, "app_permissions.txt"), 'r') as file:
            android_permissions = file.read().rstrip('\n').split('\n')
    except:
        sys.exit("app_permissions.txt could not be opened, please make sure that it is in the same directory as featureExtract.py")

    #get apk permissions
    app_permissions = app.get_permissions()
    #if apk has permission dictionary permission=1 else permission=0
    for android_permission in android_permissions:
        if android_permission in app_permissions :
            permission_present[android_permission] = 1
        else:
            permission_present[android_permission] = 0
    return permission_present

##
## fucntion gets classes from apk and checks it against app_classes.txt
##
def get_apk_classes_dict(dx):
    classes_present = dict()
    app_classess = list()

    try:
        with open(os.path.join(__location__,"app_classes.txt"), 'r') as file:
            android_classess = file.read().rstrip('\n').split('\n')
    except:
        sys.exit("app_classes.txt could not be opened,  please make sure that it is in the same directory as featureExtract.py")
    #get apk external classes calls
    app_classes = dx.get_external_classes()
    for app_class in app_classes:
            app_classess.append(app_class.get_vm_class().get_name())

    for android_classes in android_classess:
        for app_classes in app_classess:
            if android_classes in app_classes and 'Landroid' in app_classes:
                classes_present[android_classes] = 1
            if android_classes not in classes_present:
                classes_present[android_classes] = 0

    return classes_present

##
## fucntion writes classes dictionary and permission dictionary to a csv file
## with the the keys of the dict being the header for the csv
##
def append_all_features_csv(all_features_dict):
    csv_headers = list(all_features_dict.keys())
    if not os.path.isfile(os.path.join(__location__, "all_features.csv")):
        try:
            with open(os.path.join(__location__, "all_features.csv"), 'w') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=csv_headers)
                writer.writeheader()
                writer.writerow(all_features_dict)
        except:
            print("Error: could not write to all_features.csv")
    else:
        try:
            with open(os.path.join(__location__, "all_features.csv"), 'a') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=csv_headers)
                writer.writerow(all_features_dict)
        except:
            print("Error: could not append to all_features.csv")

##
## main function that is used by each forked process for apk analysis
##
def featureExtracter(apk):
    try:

        a,d,dx = AnalyzeAPK(apk)
        print("processing {}".format(apk))
        permission_dict = get_apk_permissions_dict(a)
        classes_dict = get_apk_classes_dict(dx)
        all_features_dict = {**classes_dict, **permission_dict}
        valid_permissions = sum(permission_dict.values())
        valid_classes = sum(classes_dict.values())
        if "Benign" in apk:
            permission_dict['malware'] = "Benign"
            all_features_dict['malware'] = "Benign"
        else:
            permission_dict['malware'] = "Malware"
            all_features_dict['malware'] = "Malware"
        #Aquire lock for writing to file
        with lock:
            #if error returning classes or permissions don't append to list
            if(valid_permissions != 0 and valid_classes != 0):
                append_all_features_csv(all_features_dict)

    except Exception as e:
        print("could not read {}".format(apk))

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("ApkDir", help="Folder where APKs files are held")
    try:
        options = parser.parse_args()
    except SystemExit as err:
        if err.code == 2: parser.print_help()
        sys.exit()

    apks = get_apk_files(options.ApkDir)
    if not apks:
        sys.exit("Directory does not exist or No APk files to analyse in this Directory")


    if not os.path.isfile(os.path.join(__location__, 'app_permissions.txt')):
        sys.exit("app_permissions.txt does not exist, please make sure that it is in the same direcorty as featureExtract.py")

    if not os.path.isfile(os.path.join(__location__, 'app_classes.txt')):
        sys.exit("app_classes.txt does not exist, please make sure that it is in the same direcorty as featureExtract.py")

    #pool of workers is created for multiprocessing
    pool = Pool()
    #each worker is given function and item in apk list
    pool.map(featureExtracter, apks)



if __name__ == '__main__':
        main()
